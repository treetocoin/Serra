# Implementation Plan: QR Code Device Onboarding

**Branch**: `003-qr-code-device` | **Date**: 2025-10-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-qr-code-device/spec.md`

## Summary

Implement QR code-based device onboarding flow that allows users to register ESP8266 devices through the web application, scan a QR code to connect to the device's WiFi access point, configure home WiFi credentials via captive portal, and automatically bring the device online for sensor/actuator configuration. The system supports device ID customization on the ESP8266, multi-channel error feedback (LED + webapp + auto-retry), and persistent QR code access.

## Technical Context

**Language/Version**:
- **Frontend**: TypeScript 5.9.3, React 19.1.1
- **Backend**: Supabase (PostgreSQL + Edge Functions)
- **Firmware**: C++ (Arduino framework for ESP8266)

**Primary Dependencies**:
- **Frontend**: Vite 7.1.7, React Router 7.9.3, TanStack Query 5.90.2, Tailwind CSS 4.1.14
- **Backend**: Supabase client 2.74.0
- **Firmware**: ESP8266WiFi, WiFiManager, ESP8266WebServer, ESP8266HTTPClient, ESP8266mDNS

**Storage**:
- **Database**: Supabase PostgreSQL (existing `devices` table)
- **Firmware**: EEPROM (ESP8266 persistent storage for sensor/actuator config)

**Testing**:
- **Frontend**: Manual testing (no automated tests in existing codebase)
- **Backend**: Supabase RPC function testing via SQL
- **Firmware**: Serial monitor debugging + physical device testing

**Target Platform**:
- **Frontend**: Web browsers (deployed on Netlify)
- **Backend**: Supabase cloud
- **Firmware**: ESP8266 NodeMCU (WiFi-enabled microcontroller)

**Project Type**: Web application (frontend + backend) + IoT firmware

**Performance Goals**:
- Device status update within 30 seconds of WiFi connection
- QR code generation <500ms
- Heartbeat processing <200ms
- Complete onboarding flow <5 minutes

**Constraints**:
- QR code must use standard WiFi QR format for mobile compatibility
- ESP8266 limited to 4MB flash, 80KB RAM
- WiFi AP mode has limited range (~30ft)
- Device hostname must be unique per MAC address

**Scale/Scope**:
- Support 10-50 devices per user
- Single-user setup (not bulk provisioning)
- QR code stored/regenerated on demand (not pre-computed)

## Constitution Check

*Note: No project constitution file exists yet. Standard web development best practices will be followed.*

**✅ PASSED** - No constitution violations detected. Proceeding with standard practices:
- Existing codebase structure maintained (frontend/, backend/, firmware files)
- TypeScript strict mode for type safety
- React functional components with hooks
- Supabase RPC functions for business logic
- Standard REST patterns for heartbeat endpoint

## Project Structure

### Documentation (this feature)

```
specs/003-qr-code-device/
├── plan.md              # This file
├── research.md          # Technology decisions and patterns
├── data-model.md        # Database schema changes
├── quickstart.md        # Testing guide for feature
├── contracts/           # API contracts (heartbeat, QR generation)
└── tasks.md             # Implementation tasks (generated by /speckit.tasks)
```

### Source Code (repository root)

```
frontend/
├── src/
│   ├── components/
│   │   └── devices/
│   │       ├── AddDeviceModal.tsx      # NEW: Device registration + QR code display
│   │       ├── QRCodeDisplay.tsx       # NEW: QR code generation component
│   │       └── DeviceSetup.tsx         # EXISTING: Modify to show device ID
│   ├── pages/
│   │   ├── Devices.page.tsx            # EXISTING: Add "Add Device" button
│   │   └── DeviceDetail.page.tsx       # EXISTING: Add QR code view button + device ID display
│   ├── services/
│   │   └── devices.service.ts          # EXISTING: Add registerDevice(), generateQRCode()
│   └── lib/
│       └── database.types.ts           # EXISTING: Updated types (device_id field already exists)

ESP8266_Greenhouse_WebConfig.ino        # EXISTING: Add device ID edit field to setup page

supabase/
└── migrations/
    └── [timestamp]_qr_device_onboarding.sql  # NEW: Add connection_failed status, optimize heartbeat
```

**Structure Decision**: Existing web application structure is maintained. Frontend uses component-based React architecture with services layer for API calls. ESP8266 firmware is a single .ino file with embedded web server. Supabase handles all backend logic via RPC functions and database triggers.

## Complexity Tracking

*No constitution violations - this section not needed.*

---

## Phase 0: Research & Decisions

### Research Topics

1. **QR Code Generation Library**
   - **Decision**: Use `qrcode.react` or native browser `qrcode` library
   - **Rationale**: Standard WiFi QR format ("WIFI:S:SSID;;") for maximum mobile compatibility
   - **Alternatives**: Custom QR encoding (rejected - reinventing wheel)

2. **Device Status Polling vs WebSockets**
   - **Decision**: TanStack Query with 30-second polling interval
   - **Rationale**: Existing pattern in codebase, simpler than WebSockets for low-frequency updates
   - **Alternatives**: Supabase Realtime subscriptions (rejected - adds complexity for minimal benefit)

3. **QR Code Storage**
   - **Decision**: Generate on-demand from device hostname
   - **Rationale**: Hostname is already stored, QR is deterministic, saves database space
   - **Alternatives**: Store QR as blob/base64 (rejected - unnecessary storage overhead)

4. **WiFi Connection Timeout**
   - **Decision**: 30-second timeout before ESP8266 returns to AP mode
   - **Rationale**: Balance between quick feedback and allowing slow networks
   - **Alternatives**: 60s (too slow), 15s (too fast for some routers)

5. **LED Error Patterns**
   - **Decision**: Fast blink (10Hz) for WiFi failure, solid for success, slow blink (1Hz) for connecting
   - **Rationale**: Clear visual distinction, standard Arduino patterns
   - **Alternatives**: RGB LED (not available on all ESP8266 boards)

---

## Phase 1: Design Artifacts

### Data Model

See [data-model.md](./data-model.md) for complete entity definitions.

**Key Entities**:
- `devices` table (existing) - Add `connection_status` enum with "connection_failed" state
- Device ID field (existing `id` UUID) - Add custom label field if not exists
- QR Code (computed) - Derived from `device_hostname`

### API Contracts

See [contracts/](./contracts/) for OpenAPI/RPC specifications.

**New/Modified Endpoints**:
1. `POST /devices` - Register new device, return UUID + API key
2. `GET /devices/:id/qr-code` - Generate QR code for device hostname
3. `POST /rpc/device_heartbeat` - Update status to "online" or track timeout for "connection_failed"

### Quick Start Testing Guide

See [quickstart.md](./quickstart.md) for step-by-step testing scenarios covering:
- Happy path: Register → QR scan → WiFi connect → Online
- Error path: Wrong credentials → Connection failed → Auto-retry
- QR code re-access after modal close
- Device ID customization on ESP8266

---

## Next Steps

1. ✅ Complete Phase 0: Research documented above
2. **Phase 1**: Create `data-model.md`, `contracts/`, `quickstart.md`
3. **Phase 2**: Run `/speckit.tasks` to generate implementation tasks
4. **Implementation**: Execute tasks in priority order (P1 → P2 → P3)
