# Admin User Role System Research: Supabase + React Best Practices

**Date:** 2025-11-16
**Project:** Serra
**Feature:** 006-fammi-un-tipo

## Executive Summary

This document outlines best practices for implementing an admin user role system in a Supabase PostgreSQL + React 19 + TypeScript application. The research covers five key areas: user role storage, Row Level Security policies, frontend access control, real-time synchronization, and search/pagination patterns.

---

## 1. User Role Storage in Supabase

### Decision: Custom `user_roles` Table with Auth Hooks

**Recommended Approach:**

Create a custom `user_roles` table that references `auth.users` via foreign key, and use Supabase Auth Hooks (Custom Access Token Hook) to inject the role into the JWT as a custom claim.

```sql
-- Custom types for roles
CREATE TYPE public.app_role AS ENUM ('admin', 'user');

-- User roles table
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id, role)
);

-- Enable RLS on user_roles
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Auth hook to inject role into JWT
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims JSONB;
  user_role public.app_role;
BEGIN
  -- Fetch the user role
  SELECT role INTO user_role
  FROM public.user_roles
  WHERE user_id = (event->>'user_id')::UUID;

  claims := event->'claims';

  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    claims := jsonb_set(claims, '{user_role}', '"user"');
  END IF;

  event := jsonb_set(event, '{claims}', claims);
  RETURN event;
END;
$$;

-- Grant permissions to supabase_auth_admin
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;

REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

-- Policy to allow auth admin to read user roles
CREATE POLICY "Allow auth admin to read user roles"
ON public.user_roles
AS PERMISSIVE FOR SELECT
TO supabase_auth_admin
USING (true);
```

### Rationale

1. **Security:** `user_metadata` can be modified by end users via `updateUser()`, making it insecure for authorization (see Supabase Lint 0015_rls_references_user_metadata).
2. **Flexibility:** Custom table allows for complex role relationships (multiple roles per user, role hierarchies, etc.).
3. **Performance:** Auth hooks run before token issuance, caching the role in the JWT for fast access.
4. **Auditability:** Separate table provides clear audit trail of role assignments.

### Alternatives Considered

**Alternative 1: `raw_app_metadata` Column**
- **Pros:** Cannot be modified by users, simpler to implement initially
- **Cons:**
  - Requires service role key for updates
  - Less flexible for complex role hierarchies
  - No database-level constraints or validation
  - Harder to audit role changes
- **Rejected because:** Lacks the flexibility and auditability needed for a production admin system

**Alternative 2: Direct Modification of `auth.users`**
- **Pros:** All data in one place
- **Cons:**
  - Supabase discourages modifying auth schema directly
  - Breaking changes in Supabase updates
  - Cannot use database constraints effectively
- **Rejected because:** Goes against Supabase best practices and creates maintenance risks

### Implementation Notes

1. **Enable the Auth Hook:** Navigate to Dashboard > Authentication > Hooks (Beta) and select `custom_access_token_hook`
2. **Default Role:** New users get 'user' role by default (set in hook)
3. **Admin Assignment:** Use service role key to insert admin role:
   ```sql
   INSERT INTO public.user_roles (user_id, role)
   VALUES ('dadecresce-uuid', 'admin');
   ```
4. **JWT Refresh:** Role changes require user to log out/in to refresh JWT, or implement token refresh logic
5. **Migration Strategy:**
   - Add `user_roles` table
   - Backfill existing users with default 'user' role
   - Manually assign admin role to `dadecresce@test.caz`
   - Deploy auth hook
   - Test role propagation

---

## 2. Row Level Security (RLS) Policies for Admin

### Decision: Admin Bypass Policies Using Custom Claims

**Recommended Pattern:**

Create RLS policies that check the `user_role` custom claim from the JWT and grant admin users full access while restricting regular users.

```sql
-- Helper function to check if user is admin (security definer to avoid recursion)
CREATE OR REPLACE FUNCTION private.is_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  RETURN (
    SELECT (auth.jwt() ->> 'user_role')::public.app_role = 'admin'
  );
END;
$$;

-- Example: Admin can view all projects, users can view only their own
CREATE POLICY "Admin can view all projects, users view own"
ON public.projects
FOR SELECT
TO authenticated
USING (
  (SELECT private.is_admin())
  OR
  user_id = (SELECT auth.uid())
);

-- Example: Admin can update all projects, users can update only their own
CREATE POLICY "Admin can update all projects, users update own"
ON public.projects
FOR UPDATE
TO authenticated
USING (
  (SELECT private.is_admin())
  OR
  user_id = (SELECT auth.uid())
)
WITH CHECK (
  (SELECT private.is_admin())
  OR
  user_id = (SELECT auth.uid())
);

-- Example: Admin can delete all projects, users can delete only their own
CREATE POLICY "Admin can delete all projects, users delete own"
ON public.projects
FOR DELETE
TO authenticated
USING (
  (SELECT private.is_admin())
  OR
  user_id = (SELECT auth.uid())
);

-- Example: Anyone authenticated can insert (admin check optional)
CREATE POLICY "Authenticated users can create projects"
ON public.projects
FOR INSERT
TO authenticated
WITH CHECK (
  user_id = (SELECT auth.uid())
);
```

### Rationale

1. **Performance:** Wrapping `auth.jwt()` in a `SELECT` statement creates an `initPlan` that caches the result per-statement (99.94% performance improvement per Supabase benchmarks)
2. **Security Definer:** Prevents RLS recursion issues and improves performance
3. **Explicit Role Checks:** Clear, maintainable policies that are easy to audit
4. **Follows Supabase Best Practices:** Aligns with official RLS performance recommendations

### Security Considerations

1. **Never Use `user_metadata`:** It can be modified by users via client libraries
2. **Always Use `TO authenticated`:** Prevents policy from running for anonymous users
3. **Index User Columns:** Create indexes on columns used in policies (e.g., `user_id`)
   ```sql
   CREATE INDEX idx_projects_user_id ON public.projects(user_id);
   ```
4. **Private Schema for Helper Functions:** Never expose security definer functions in public schema
   ```sql
   CREATE SCHEMA IF NOT EXISTS private;
   ```
5. **Test Policies Thoroughly:** Use `SET ROLE` to test as different users:
   ```sql
   -- Test as regular user
   SET ROLE authenticated;
   SET request.jwt.claims.user_role = 'user';
   SET request.jwt.claims.sub = '<user-uuid>';
   SELECT * FROM projects; -- Should see only their projects

   -- Test as admin
   SET request.jwt.claims.user_role = 'admin';
   SELECT * FROM projects; -- Should see all projects
   ```

### Alternatives Considered

**Alternative 1: Service Role Key Bypass**
- **Pros:** Simple, no policy modifications needed
- **Cons:**
  - Requires service role key in frontend (major security risk)
  - Cannot be used with RLS
  - No audit trail of admin actions
- **Rejected because:** Major security vulnerability

**Alternative 2: Separate Admin Views**
- **Pros:** Complete separation of concerns
- **Cons:**
  - Code duplication
  - Harder to maintain
  - More complex schema
- **Rejected because:** Unnecessary complexity when RLS can handle both cases

### Implementation Notes

1. **Create Private Schema First:**
   ```sql
   CREATE SCHEMA IF NOT EXISTS private;
   ```
2. **Keep Helper Functions in Private Schema:** Never expose them via PostgREST
3. **Add Indexes on Filter Columns:** Critical for performance at scale
4. **Use Restrictive Policies:** Default deny, explicitly allow
5. **Test with Real User Sessions:** Use Supabase Dashboard SQL Editor with user context

---

## 3. Frontend Role-Based Access Control

### Decision: JWT-Based Role Checking with React Query

**Recommended Approach:**

Decode the JWT on the client to access the `user_role` custom claim, and use React hooks for role-based rendering and route protection.

**1. Create a Custom Hook to Access User Role:**

```typescript
// hooks/useUserRole.ts
import { useEffect, useState } from 'react';
import { useSupabaseClient, useUser } from '@supabase/auth-helpers-react';
import { jwtDecode } from 'jwt-decode';

interface JWTPayload {
  user_role?: 'admin' | 'user';
  sub: string;
  // ... other JWT claims
}

export function useUserRole() {
  const supabase = useSupabaseClient();
  const user = useUser();
  const [role, setRole] = useState<'admin' | 'user' | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function getUserRole() {
      if (!user) {
        setRole(null);
        setLoading(false);
        return;
      }

      const { data: { session } } = await supabase.auth.getSession();

      if (session?.access_token) {
        const decoded = jwtDecode<JWTPayload>(session.access_token);
        setRole(decoded.user_role || 'user');
      } else {
        setRole('user');
      }

      setLoading(false);
    }

    getUserRole();
  }, [user, supabase]);

  return {
    role,
    isAdmin: role === 'admin',
    loading
  };
}
```

**2. Protect Routes with Higher-Order Component:**

```typescript
// components/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { useUserRole } from '../hooks/useUserRole';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requireAdmin?: boolean;
}

export function ProtectedRoute({ children, requireAdmin = false }: ProtectedRouteProps) {
  const { role, loading } = useUserRole();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (requireAdmin && role !== 'admin') {
    return <Navigate to="/unauthorized" replace />;
  }

  return <>{children}</>;
}
```

**3. Use in React Router:**

```typescript
// App.tsx or router configuration
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { ProtectedRoute } from './components/ProtectedRoute';
import AdminDashboard from './pages/AdminDashboard';
import UserDashboard from './pages/UserDashboard';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/dashboard" element={<UserDashboard />} />
        <Route
          path="/admin"
          element={
            <ProtectedRoute requireAdmin>
              <AdminDashboard />
            </ProtectedRoute>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}
```

**4. Conditionally Render UI Elements:**

```typescript
// components/ProjectList.tsx
import { useUserRole } from '../hooks/useUserRole';

export function ProjectList() {
  const { isAdmin } = useUserRole();

  return (
    <div>
      {isAdmin && (
        <button>Edit All Projects</button>
      )}
      <ProjectTable showAllUsers={isAdmin} />
    </div>
  );
}
```

### Rationale

1. **Client-Side Validation:** Fast, no additional API calls needed
2. **Type Safety:** TypeScript interfaces for JWT payload
3. **Reusable Hook:** DRY principle, easy to maintain
4. **Loading States:** Prevents flash of unauthorized content
5. **React Query Compatible:** Can be combined with data fetching

### Best Practices

1. **Never Trust Client-Side Checks Alone:** Always enforce RLS on database
2. **Handle Token Expiration:**
   ```typescript
   useEffect(() => {
     const { data: { subscription } } = supabase.auth.onAuthStateChange((event) => {
       if (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') {
         // Re-decode JWT to get updated role
         getUserRole();
       }
     });

     return () => subscription.unsubscribe();
   }, []);
   ```
3. **Provide Unauthorized Feedback:**
   ```typescript
   // pages/Unauthorized.tsx
   export function Unauthorized() {
     return (
       <div>
         <h1>Access Denied</h1>
         <p>You do not have permission to access this page.</p>
       </div>
     );
   }
   ```
4. **Cache Role Information:** Use React Context or state management to avoid repeated JWT decoding
5. **Handle JWT Refresh:** Subscribe to auth state changes to update role when token refreshes

### Alternatives Considered

**Alternative 1: Database Query for Role**
- **Pros:** Always up-to-date
- **Cons:**
  - Extra API call on every route change
  - Slower user experience
  - More database load
- **Rejected because:** JWT approach is faster and leverages existing session

**Alternative 2: Server-Side Route Protection Only**
- **Pros:** More secure
- **Cons:**
  - Poor UX (page loads then redirects)
  - Wasted bandwidth
  - Doesn't hide UI elements
- **Rejected because:** Should be used in combination with client-side, not alone

### Implementation Notes

1. **Install jwt-decode:**
   ```bash
   npm install jwt-decode
   ```
2. **TypeScript Types:** Create interface for JWT payload with all custom claims
3. **Loading State:** Show skeleton or spinner while checking role
4. **Error Handling:** Handle malformed JWTs gracefully
5. **Development vs Production:** Consider mock admin role for development

---

## 4. Real-time Sync for Multi-User Scenarios

### Decision: Supabase Realtime with Broadcast for Admin Changes

**Recommended Approach:**

Use Supabase Realtime subscriptions to notify project owners when admin makes changes, ensuring immediate UI updates without polling.

**1. Subscribe to Database Changes (for non-admin users):**

```typescript
// hooks/useProjectSync.ts
import { useEffect } from 'react';
import { useSupabaseClient } from '@supabase/auth-helpers-react';
import { useQueryClient } from '@tanstack/react-query';
import { useUserRole } from './useUserRole';

export function useProjectSync(projectId: string) {
  const supabase = useSupabaseClient();
  const queryClient = useQueryClient();
  const { isAdmin } = useUserRole();

  useEffect(() => {
    // Only non-admin users need real-time updates for their projects
    if (isAdmin) return;

    const channel = supabase
      .channel(`project:${projectId}`)
      .on(
        'postgres_changes',
        {
          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
          schema: 'public',
          table: 'projects',
          filter: `id=eq.${projectId}`,
        },
        (payload) => {
          console.log('Project updated:', payload);

          // Invalidate React Query cache to refetch data
          queryClient.invalidateQueries(['project', projectId]);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [projectId, supabase, queryClient, isAdmin]);
}
```

**2. Use in Component:**

```typescript
// pages/ProjectDetail.tsx
import { useQuery } from '@tanstack/react-query';
import { useParams } from 'react-router-dom';
import { useProjectSync } from '../hooks/useProjectSync';

export function ProjectDetail() {
  const { projectId } = useParams();
  const supabase = useSupabaseClient();

  // Enable real-time sync
  useProjectSync(projectId);

  const { data: project, isLoading } = useQuery(
    ['project', projectId],
    async () => {
      const { data } = await supabase
        .from('projects')
        .select('*')
        .eq('id', projectId)
        .single();
      return data;
    }
  );

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <h1>{project.name}</h1>
      <p>Last updated: {project.updated_at}</p>
    </div>
  );
}
```

**3. Admin Optimistic Updates:**

```typescript
// hooks/useUpdateProject.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useSupabaseClient } from '@supabase/auth-helpers-react';

export function useUpdateProject() {
  const supabase = useSupabaseClient();
  const queryClient = useQueryClient();

  return useMutation(
    async ({ id, updates }: { id: string; updates: any }) => {
      const { data, error } = await supabase
        .from('projects')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    {
      onMutate: async ({ id, updates }) => {
        // Cancel outgoing refetches
        await queryClient.cancelQueries(['project', id]);

        // Snapshot previous value
        const previous = queryClient.getQueryData(['project', id]);

        // Optimistically update
        queryClient.setQueryData(['project', id], (old: any) => ({
          ...old,
          ...updates,
        }));

        return { previous };
      },
      onError: (err, variables, context) => {
        // Rollback on error
        if (context?.previous) {
          queryClient.setQueryData(['project', variables.id], context.previous);
        }
      },
      onSettled: (data, error, variables) => {
        // Refetch after mutation
        queryClient.invalidateQueries(['project', variables.id]);
      },
    }
  );
}
```

### Rationale

1. **Immediate Updates:** Changes visible to all users within milliseconds
2. **Efficient:** Only affected records trigger updates
3. **Built-in:** Leverages Supabase's native real-time capabilities
4. **React Query Integration:** Seamless cache invalidation and refetching
5. **Optimistic Updates for Admin:** Better UX, instant feedback

### Best Practices

1. **Filter Subscriptions:** Use RLS policies to ensure users only receive updates for their data
   ```sql
   -- RLS policy for realtime
   CREATE POLICY "Users can subscribe to own projects"
   ON public.projects
   FOR SELECT
   TO authenticated
   USING (
     (SELECT private.is_admin())
     OR
     user_id = (SELECT auth.uid())
   );
   ```

2. **Enable Realtime on Table:**
   ```sql
   -- Enable realtime for projects table
   ALTER PUBLICATION supabase_realtime ADD TABLE public.projects;
   ```

3. **Handle Connection States:**
   ```typescript
   const channel = supabase
     .channel(`project:${projectId}`)
     .on('postgres_changes', { ... }, callback)
     .subscribe((status) => {
       if (status === 'SUBSCRIBED') {
         console.log('Connected to realtime');
       }
       if (status === 'CHANNEL_ERROR') {
         console.error('Realtime error, retrying...');
       }
     });
   ```

4. **Cleanup Subscriptions:** Always unsubscribe in cleanup function
5. **Batch Updates:** Use debouncing to avoid excessive invalidations
   ```typescript
   const debouncedInvalidate = debounce(() => {
     queryClient.invalidateQueries(['projects']);
   }, 500);
   ```

### Alternatives Considered

**Alternative 1: Polling**
- **Pros:** Simple, works everywhere
- **Cons:**
  - Wasteful (constant requests)
  - Delayed updates
  - Higher server load
- **Rejected because:** Realtime provides better UX and efficiency

**Alternative 2: WebSockets Only**
- **Pros:** More control
- **Cons:**
  - Requires custom server
  - More complex to implement
  - Reinvents what Supabase provides
- **Rejected because:** Supabase Realtime is production-ready and integrated

### Implementation Notes

1. **Realtime Quotas:** Free tier has 500 concurrent connections, monitor usage
2. **RLS Applies:** Real-time respects RLS policies
3. **Channel Naming:** Use consistent naming convention (`table:id:action`)
4. **Error Handling:** Handle reconnection and subscription errors
5. **Development:** Use different channels for dev/staging/prod

---

## 5. Search and Pagination Patterns

### Decision: Cursor-Based Pagination with Full-Text Search

**Recommended Approach:**

Use cursor-based pagination for large datasets (better performance than offset) combined with PostgreSQL full-text search for filtering.

**1. Full-Text Search Setup:**

```sql
-- Add tsvector column for full-text search
ALTER TABLE public.projects
ADD COLUMN fts tsvector
GENERATED ALWAYS AS (
  to_tsvector('english',
    COALESCE(name, '') || ' ' ||
    COALESCE(description, '')
  )
) STORED;

-- Create GIN index for fast full-text search
CREATE INDEX idx_projects_fts ON public.projects USING GIN(fts);

-- Create index on id for cursor pagination
CREATE INDEX idx_projects_id ON public.projects(id);
```

**2. Cursor-Based Pagination Helper:**

```typescript
// lib/pagination.ts
import { SupabaseClient } from '@supabase/supabase-js';

export interface PaginationOptions {
  pageSize?: number;
  cursor?: string; // Last seen ID
  searchQuery?: string;
  orderBy?: string;
  orderDirection?: 'asc' | 'desc';
}

export async function fetchProjectsPage(
  supabase: SupabaseClient,
  options: PaginationOptions = {}
) {
  const {
    pageSize = 20,
    cursor,
    searchQuery,
    orderBy = 'created_at',
    orderDirection = 'desc',
  } = options;

  let query = supabase
    .from('projects')
    .select('*', { count: 'exact' });

  // Apply full-text search if query provided
  if (searchQuery) {
    query = query.textSearch('fts', searchQuery);
  }

  // Apply cursor for pagination (fetch records after cursor)
  if (cursor) {
    query = query.gt('id', cursor);
  }

  // Apply ordering
  query = query
    .order(orderBy, { ascending: orderDirection === 'asc' })
    .limit(pageSize);

  const { data, error, count } = await query;

  if (error) throw error;

  // Get cursor for next page (last record's ID)
  const nextCursor = data && data.length > 0
    ? data[data.length - 1].id
    : null;

  return {
    data,
    nextCursor,
    hasMore: data ? data.length === pageSize : false,
    total: count,
  };
}
```

**3. React Query Integration:**

```typescript
// hooks/useProjects.ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { useSupabaseClient } from '@supabase/auth-helpers-react';
import { fetchProjectsPage } from '../lib/pagination';

export function useProjects(searchQuery?: string) {
  const supabase = useSupabaseClient();

  return useInfiniteQuery(
    ['projects', searchQuery],
    ({ pageParam }) =>
      fetchProjectsPage(supabase, {
        cursor: pageParam,
        searchQuery,
        pageSize: 20,
      }),
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
      keepPreviousData: true,
      staleTime: 30000, // Cache for 30 seconds
    }
  );
}
```

**4. Infinite Scroll Component:**

```typescript
// components/ProjectList.tsx
import { useProjects } from '../hooks/useProjects';
import { useInView } from 'react-intersection-observer';
import { useEffect } from 'react';

export function ProjectList({ searchQuery }: { searchQuery?: string }) {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useProjects(searchQuery);

  const { ref, inView } = useInView();

  // Load more when scrolled to bottom
  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  const projects = data?.pages.flatMap((page) => page.data) || [];

  return (
    <div>
      {projects.map((project) => (
        <ProjectCard key={project.id} project={project} />
      ))}

      {hasNextPage && (
        <div ref={ref}>
          {isFetchingNextPage ? 'Loading more...' : 'Load more'}
        </div>
      )}
    </div>
  );
}
```

**5. Admin View All Projects:**

```typescript
// pages/AdminProjects.tsx
import { useState } from 'react';
import { useProjects } from '../hooks/useProjects';
import { debounce } from 'lodash';

export function AdminProjects() {
  const [search, setSearch] = useState('');
  const { data, isLoading } = useProjects(search);

  // Debounce search to avoid excessive queries
  const handleSearch = debounce((value: string) => {
    setSearch(value);
  }, 300);

  return (
    <div>
      <h1>All Projects (Admin View)</h1>
      <input
        type="search"
        placeholder="Search projects..."
        onChange={(e) => handleSearch(e.target.value)}
      />

      {isLoading && <div>Loading...</div>}

      <ProjectList searchQuery={search} />
    </div>
  );
}
```

### Rationale

1. **Performance:** Cursor-based pagination avoids counting all rows for offset
2. **Scalability:** Works efficiently with millions of records
3. **Full-Text Search:** Native PostgreSQL FTS is fast and accurate
4. **React Query:** Handles caching, loading states, and infinite scroll
5. **Admin Access:** RLS policies automatically filter data based on role

### Pagination Method Comparison

| Method | Best For | Performance | Pros | Cons |
|--------|----------|-------------|------|------|
| **Cursor-based** | Large datasets (>10k rows) | Excellent | Fast, scales well, handles inserts/deletes | Can't jump to arbitrary page |
| **Offset/Limit** | Small datasets (<10k rows) | Good for small offsets | Simple, can jump to any page | Slow with large offsets, inefficient |
| **Keyset** | Time-series data | Excellent | Very fast, predictable | Requires indexed column |

### Best Practices

1. **Index Everything Used in Queries:**
   ```sql
   CREATE INDEX idx_projects_created_at ON public.projects(created_at);
   CREATE INDEX idx_projects_user_id ON public.projects(user_id);
   ```

2. **Limit Max Page Size:**
   ```typescript
   const MAX_PAGE_SIZE = 100;
   const pageSize = Math.min(requestedPageSize, MAX_PAGE_SIZE);
   ```

3. **Cache Search Results:**
   ```typescript
   const { data } = useQuery(
     ['projects', searchQuery],
     fetchProjects,
     {
       staleTime: 60000, // Cache for 1 minute
       cacheTime: 300000, // Keep in cache for 5 minutes
     }
   );
   ```

4. **Debounce Search Input:**
   ```typescript
   const debouncedSearch = useMemo(
     () => debounce((value) => setSearch(value), 300),
     []
   );
   ```

5. **Count Rows Sparingly:** Row counting is expensive, cache it or use estimates
   ```sql
   -- Fast estimate for large tables
   SELECT reltuples::BIGINT AS estimate
   FROM pg_class
   WHERE relname = 'projects';
   ```

6. **Use Specific Columns:** Don't `SELECT *`, specify only needed columns
   ```typescript
   .select('id, name, description, created_at')
   ```

### Alternatives Considered

**Alternative 1: Offset/Limit Pagination**
- **Pros:** Simple, can jump to any page
- **Cons:**
  - Very slow with large offsets (scans all rows)
  - Inconsistent results when data changes
- **Rejected because:** Poor performance with large datasets (>10k rows)

**Alternative 2: External Search Service (Algolia, Elasticsearch)**
- **Pros:**
  - Advanced search features (typo tolerance, synonyms)
  - Very fast
- **Cons:**
  - Additional cost
  - Data sync complexity
  - Overkill for simple use cases
- **Rejected because:** PostgreSQL FTS is sufficient for most use cases

**Alternative 3: Client-Side Pagination**
- **Pros:** Very fast after initial load
- **Cons:**
  - Loads all data upfront
  - Memory intensive
  - Doesn't scale
- **Rejected because:** Not feasible for large datasets

### Implementation Notes

1. **Install Dependencies:**
   ```bash
   npm install @tanstack/react-query react-intersection-observer lodash
   npm install -D @types/lodash
   ```

2. **Monitor Query Performance:** Use `EXPLAIN ANALYZE` in SQL editor
   ```sql
   EXPLAIN ANALYZE
   SELECT * FROM projects
   WHERE fts @@ to_tsquery('english', 'greenhouse')
   ORDER BY id
   LIMIT 20;
   ```

3. **Handle Edge Cases:**
   - Empty search results
   - Network errors
   - Stale cursors (data deleted)

4. **Progressive Enhancement:**
   - Start with basic pagination
   - Add search incrementally
   - Add filters as needed

5. **Real-Time Compatibility:** Cursor-based pagination works with real-time updates, just invalidate cache on changes

---

## Additional Considerations

### JWT Freshness

**Issue:** When admin removes user's role, JWT still contains old role until refresh.

**Solutions:**
1. **Force Token Refresh:** Call `supabase.auth.refreshSession()` after role change
2. **Short Token Lifetime:** Reduce JWT expiry time (default 1 hour)
3. **Server-Side Validation:** Always check database for critical operations
4. **Logout Other Sessions:** Implement session management to invalidate old tokens

### Performance Monitoring

**Key Metrics:**
- Query execution time (target: <100ms for p95)
- RLS policy overhead (use `EXPLAIN ANALYZE`)
- Real-time connection count
- Cache hit rate

**Tools:**
- Supabase Dashboard (Logs, Performance)
- PostgreSQL `pg_stat_statements` extension
- React Query DevTools

### Security Checklist

- [ ] RLS enabled on all tables
- [ ] Policies use `TO authenticated` clause
- [ ] Helper functions in private schema
- [ ] Never expose service role key to client
- [ ] Test policies with different user roles
- [ ] Audit logs for admin actions
- [ ] Rate limiting on admin endpoints
- [ ] Input validation and sanitization

### Testing Strategy

1. **Unit Tests:** Test role checking functions
2. **Integration Tests:** Test RLS policies with different user contexts
3. **E2E Tests:** Test admin workflows end-to-end
4. **Load Tests:** Verify pagination performance with large datasets
5. **Security Tests:** Attempt unauthorized access

---

## References

### Official Supabase Documentation
- [Custom Claims & RBAC](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac)
- [Row Level Security](https://supabase.com/docs/guides/database/postgres/row-level-security)
- [RLS Performance Best Practices](https://github.com/orgs/supabase/discussions/14576)
- [Full Text Search](https://supabase.com/docs/guides/database/full-text-search)
- [Realtime](https://supabase.com/docs/guides/realtime)
- [JWT Claims Reference](https://supabase.com/docs/guides/auth/jwt-fields)

### Community Resources
- [Supabase RBAC Discussion #346](https://github.com/orgs/supabase/discussions/346)
- [How to Implement RBAC in Supabase (Permit.io)](https://www.permit.io/blog/how-to-implement-rbac-in-supabase)
- [Pagination with Supabase (ITNEXT)](https://itnext.io/supabase-paginate-results-782be35c3fea)

### Performance Benchmarks
- RLS Performance Tests: https://github.com/GaryAustin1/RLS-Performance
- Wrapping auth.uid() in SELECT: 94.97% improvement
- Using security definer functions: 99.993% improvement
- Adding filters to queries: 94.74% improvement

---

## Recommended Implementation Order

1. **Week 1: Database Setup**
   - Create `user_roles` table
   - Implement auth hook
   - Create RLS policies with admin bypass
   - Test policies thoroughly

2. **Week 2: Frontend Role Checking**
   - Implement `useUserRole` hook
   - Create route protection components
   - Add conditional UI rendering
   - Handle loading and error states

3. **Week 3: Admin Features**
   - Build admin dashboard
   - Implement project management UI
   - Add real-time sync for users
   - Test multi-user scenarios

4. **Week 4: Search & Pagination**
   - Add full-text search indexes
   - Implement cursor-based pagination
   - Create infinite scroll UI
   - Performance testing and optimization

5. **Week 5: Polish & Testing**
   - End-to-end testing
   - Performance optimization
   - Security audit
   - Documentation

---

**Document Version:** 1.0
**Last Updated:** 2025-11-16
**Author:** Claude (Sonnet 4.5)
